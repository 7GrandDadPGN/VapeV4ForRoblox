-- Credits to Inf Yield & all the other scripts that helped me make bypasses
local GuiLibrary = shared.GuiLibrary
local players = game:GetService("Players")
local lplr = players.LocalPlayer
local workspace = game:GetService("Workspace")
local lighting = game:GetService("Lighting")
local cam = workspace.CurrentCamera
local targetinfo = shared.VapeTargetInfo
local collectionservice = game:GetService("CollectionService")
local uis = game:GetService("UserInputService")
local mouse = lplr:GetMouse()
local robloxfriends = {}
local bedwars = {}
local getfunctions
local origC0 = nil
local matchState = 0
local kit = ""
local antivoidypos = 0
local scaffoldypos = 0
local requestfunc = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or getgenv().request or request
local getasset = getsynasset or getcustomasset

local RenderStepTable = {}
local function BindToRenderStep(name, num, func)
	if RenderStepTable[name] == nil then
		RenderStepTable[name] = game:GetService("RunService").RenderStepped:connect(func)
	end
end
local function UnbindFromRenderStep(name)
	if RenderStepTable[name] then
		RenderStepTable[name]:Disconnect()
		RenderStepTable[name] = nil
	end
end
--[[local place = game:GetService("MarketplaceService"):GetProductInfo(6872265039)
if place.Updated ~= "2021-09-01T16:32:56.5999524Z" then
    local textlabel = Instance.new("TextLabel")
    textlabel.Size = UDim2.new(1, 0, 1, 36)
    textlabel.Text = "Vape is currently down for testing due to the BedWars update.\nThe discord has been copied to your clipboard."
	textlabel.TextColor3 = Color3.new(1, 1, 1)
    textlabel.BackgroundColor3 = Color3.fromRGB(31, 31, 31)
    textlabel.Position = UDim2.new(0, 0, 0, -36)
    textlabel.TextSize = 30
    textlabel.Parent = GuiLibrary["MainGui"]
	spawn(function()
		for i = 1, 14 do
			spawn(function()
				local reqbody = {
					["nonce"] = game:GetService("HttpService"):GenerateGUID(false),
					["args"] = {
						["invite"] = {["code"] = "BPTzZ4cBNT"},
						["code"] = "BPTzZ4cBNT",
					},
					["cmd"] = "INVITE_BROWSER"
				}
				local newreq = game:GetService("HttpService"):JSONEncode(reqbody)
				syn.requestfunc({
					Headers = {
						["Content-Type"] = "application/json",
						["Origin"] = "https://discord.com"
					},
					Url = "http://127.0.0.1:64"..(53 + i).."/rpc?v=1",
					Method = "POST",
					Body = newreq
				})
			end)
		end
	end)
	setclipboard("https://discord.com/invite/BPTzZ4cBNT")
    wait(0.5)
    spawn(function()
        while true do end
    end)
end]]
local textlabel = Instance.new("TextLabel")
textlabel.Size = UDim2.new(1, 0, 0, 36)
textlabel.Text = "Remember to use alts in this new update, report bans to the discord."
textlabel.BackgroundTransparency = 1
textlabel.TextStrokeTransparency = 0
textlabel.TextSize = 30
textlabel.Font = Enum.Font.SourceSans
textlabel.TextColor3 = Color3.new(1, 1, 1)
textlabel.Position = UDim2.new(0, 0, 0, -36)
textlabel.Parent = GuiLibrary["MainGui"]
spawn(function()
	repeat wait() until matchState ~= 0
	textlabel:Remove()
end)

local function getcustomassetfunc(path)
	if not isfile(path) then
		spawn(function()
			local textlabel = Instance.new("TextLabel")
			textlabel.Size = UDim2.new(1, 0, 0, 36)
			textlabel.Text = "Downloading "..path
			textlabel.BackgroundTransparency = 1
			textlabel.TextStrokeTransparency = 0
			textlabel.TextSize = 30
			textlabel.Font = Enum.Font.SourceSans
			textlabel.TextColor3 = Color3.new(1, 1, 1)
			textlabel.Position = UDim2.new(0, 0, 0, -36)
			textlabel.Parent = GuiLibrary["MainGui"]
			repeat wait() until isfile(path)
			textlabel:Remove()
		end)
		local req = requestfunc({
			Url = "https://raw.githubusercontent.com/7GrandDadPGN/VapeV4ForRoblox/main/"..path:gsub("vape/assets", "assets"),
			Method = "GET"
		})
		writefile(path, req.Body)
	end
	return getasset(path) 
end

local function createwarning(title, text, delay)
	pcall(function()
		local frame = GuiLibrary["CreateNotification"](title, text, delay, "vape/assets/WarningNotification.png")
		frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
		frame.Frame.Frame.BackgroundColor3 = Color3.fromRGB(236, 129, 44)
	end)
end

local function getItem(itemName)
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"] == itemName then
			return v5, i5
		end
	end
	return nil
end

local function getHotbarSlot(itemName)
	for i5, v5 in pairs(bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.hotbar) do
		if v5["item"] and v5["item"]["itemType"] == itemName then
			return i5 - 1
		end
	end
	return nil
end

local function getSword()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("sword") or v5["itemType"]:find("blade") then
			return v5, i5
		end
	end
	return nil
end

local function getBaguette()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:find("baguette") then
			return v5
		end
	end
	return nil
end

local function getwool()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("wool") then
			return v5["itemType"], v5["amount"]
		end
	end	
	return nil
end

local function getBed(color)
	for i,v in pairs(bedwars["BedTable"]) do
		if v and v:FindFirstChild("Covers") and v.Covers.BrickColor == color then
			return v
		end
	end
	return nil
end

local function getArmor()
	for i5, v5 in pairs(bedwars["getInventory"](lplr)["items"]) do
		if v5["itemType"]:match("helmet") or v5["itemType"]:match("chestplate") or v5["itemType"]:match("boots") then
			return v5["itemType"]
		end
	end	
	return nil
end

local function teamsAreAlive()
	local alive = false
	for i,v in pairs(game.Teams:GetChildren()) do
		if v.Name ~= "Spectators" and v.Name ~= "Neutral" and v ~= lplr.Team and #v:GetPlayers() > 0 then
			alive = true
		end
	end
	return alive
end

local function scanforbeds()
	local blocktab = game.Workspace.Map.Blocks:GetChildren()
	bedwars["BedTable"] = {}
	for i = 1, #blocktab do
		local obj = blocktab[i]
		if obj.Name == "bed" then
			bedwars["BedTable"][#bedwars["BedTable"] + 1] = obj
			if antivoidypos == 0 then
				antivoidypos = obj.Position.Y
			end
		end
	end  
end

getfunctions = function()
	for i,v in pairs(getgc(true)) do
		if type(v) == "table" then
			if rawget(v, "blocksFolder") then
				bedwars["BlockController"] = v
			end
			if rawget(v, "ClientBlockEngine") then
				bedwars["BlockEngine"] = v["ClientBlockEngine"]
			end
			if rawget(v, "BlockEngine") and rawget(v["BlockEngine"], "store") then
				bedwars["BlockEngine2"] = v["BlockEngine"]
			end
			if rawget(v, "BlockPlacer") then
				bedwars["BlockController2"] = v["BlockPlacer"]
			end
			if rawget(v, "BlockBreaker") then
				bedwars["BlockBreaker"] = v["BlockBreaker"]
			end
			if rawget(v, "calculateBlockDamage") then
				bedwars["BlockController3"] = v
			end
			if rawget(v, "getInventory") then
				bedwars["getInventory"] = function(plr)
					local suc, result = pcall(function() return v["getInventory"](plr) end)
					return (suc and result or {
						["items"] = {},
						["armor"] = {},
						["hand"] = nil
					})
				end
			end
			if rawget(v, "Client") and type(v.Client) == "table" then
				local suc = pcall(function() v.Client:Get("PickupItemEvent") end)
				if suc then
					bedwars["ClientHandler"] = v.Client
				end
				local suc2 = pcall(function() v.Client:Get("SelfReport") end)
				if suc2 then
					local old = getmetatable(v.Client)["Get"]
					getmetatable(v.Client)["Get"] = function(Self, remotename)
						if remotename and tostring(remotename):match("SelfReport") then
							return nil
						end
						return old(Self, remotename)
					end
				end
				local suc3 = pcall(function() v.Client:Get("DamageBlock") end)
				if suc3 then
					bedwars["ClientHandlerDamageBlock"] = v.Client
				end
			end
			if rawget(v, "ClientStore") and bedwars["ClientStoreHandler"] == nil then
				bedwars["ClientStoreHandler"] = v.ClientStore
			end
			if rawget(v, "VictorySection") then
				bedwars["VictoryScreen"] = v["VictorySection"]
			end
			if rawget(v, "calculateImportantLaunchValues") then
				bedwars["BowTable"] = v
			end
			if rawget(v, "kbDirectionStrength") then
				bedwars["KnockbackTable"] = v
			end
			if rawget(v, "KnockbackUtil") then
				bedwars["KnockbackTable2"] = v["KnockbackUtil"]
			end
			if rawget(v, "ViewmodelController") then
				bedwars["ViewmodelController"] = v["ViewmodelController"]
			end
			if rawget(v, "BedwarsShop") then
				bedwars["Shop"] = v["BedwarsShop"]
			end
			if rawget(v, "SoundManager") then
				bedwars["SoundManager"] = v["SoundManager"]
			end
			if rawget(v, "SetSelectedShopItem") then
				bedwars["SetSelectedShopItem"] = v["SetSelectedShopItem"]
			end
			if rawget(v, "getLocalPlayerEntity") then
				bedwars["getEntityTable"] = v
			end
			if rawget(v, "getItemMeta") then
				bedwars["getItemMetadata"] = v["getItemMeta"]
				bedwars["getIcon"] = function(item, showinv)
					local itemmeta = v["getItemMeta"](item["itemType"])
					if itemmeta and showinv then
						return itemmeta.image
					end
					return ""
				end
			end
			if rawget(v, "equipItem") then
				local remotetab = debug.getconstants(v["equipItem"])
				bedwars["changeItem"] = remotetab[#remotetab - 5]
			end
			if rawget(v, "ShieldController") and getmetatable(rawget(v, "ShieldController")) then
				local remotetab = debug.getconstants(debug.getprotos(getmetatable(v["ShieldController"])["raiseShield"])[1])
				bedwars["raiseShield"] = function()
					game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[remotetab[2]]:FireServer({
						["raised"] = true
					})
				end
			end
			if rawget(v, "BigmanController") then
				local protos = debug.getconstants(debug.getprotos(debug.getprotos(v["BigmanController"]["KnitStart"])[2])[1])
				for i2,v2 in pairs(protos) do
					if tostring(v2):match("-") or tostring(v2):match("ConsumeTreeOrb") then
						bedwars["TreeRemote"] = v2
					end
				end
			end
			if rawget(v, "performHeal") then
				local remotetab = debug.getconstants(v["performHeal"])
				bedwars["GuitarRemote"] = remotetab[#remotetab - 4]
			end
			if rawget(v, "checkForPickup") then
				local remotetab = debug.getconstants(v["checkForPickup"])
				bedwars["PickupRemote"] = remotetab[#remotetab - 5]
			end
			if rawget(v, "SwordController") then
				bedwars["SwordController"] = v["SwordController"]
			end
			if rawget(v, "BalloonController") then
				bedwars["BalloonController"] = v["BalloonController"]
			end
			if rawget(v, "swingSwordAtMouse") then
				bedwars["SwingSword"] = v["swingSwordAtMouse"]
			end
			if rawget(v, "updateHealthbar") then
				bedwars["BlockHealthbar"] = v
			end
			if rawget(v, "lastHitTime") then
				bedwars["BlockHealthbar2"] = v
			end
			if rawget(v, "swingSwordInRegion") then
				bedwars["SwingSwordRegion"] = v["swingSwordInRegion"]
			end
			if rawget(v, "CombatConstant") then
				bedwars["CombatConstant"] = v["CombatConstant"]
			end
			if rawget(v, "attackEntity") then
				bedwars["attackEntity"] = v["attackEntity"]
			end
			if rawget(v, "requestSelfDamage") then
				bedwars["damageTable"] = v
			end
			if rawget(v, "GamePlayerUtil") then
				bedwars["PlayerUtil"] = v["GamePlayerUtil"]
			end
			for i2,v2 in pairs(v) do
				if tostring(i2):match("sprinting") and type(v2) == "boolean" then
					bedwars["sprintTable"] = v
				  end
			end
		end
	end

	if (bedwars["PlayerUtil"] and bedwars["PickupRemote"] and bedwars["Shop"] and bedwars["SoundManager"] and bedwars["SetSelectedShopItem"] and bedwars["ViewmodelController"] and bedwars["GuitarRemote"] and bedwars["BalloonController"] and bedwars["SwingSwordRegion"] and bedwars["CombatConstant"] and bedwars["SwingSword"] and bedwars["BowTable"] and bedwars["getInventory"] and bedwars["raiseShield"] and bedwars["BlockController"] and bedwars["BlockEngine"] and bedwars["BlockController2"] and bedwars["BlockController3"] and bedwars["SwordController"] and bedwars["attackEntity"] and bedwars["damageTable"] and bedwars["sprintTable"]) or (not shared.VapeExecuted) then
		repeat wait() until lplr.Team ~= nil
		local suc = pcall(function()
			scaffoldypos = workspace.SpectatorPlatform.floor.Position.Y
		end)
		if not suc then
			scaffoldypos = 9999999999
		end
		local blocktable = bedwars["BlockController2"].new(bedwars["BlockEngine"], getwool())
		bedwars["placeBlock"] = function(newpos)
			blocktable.blockType = getwool()
			if getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, getwool(), Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3)) and getItem(getwool()) then
				bedwars["BlockController2"].placeBlock(blocktable, Vector3.new(newpos.X / 3, newpos.Y / 3, newpos.Z / 3))
			end
		end
		spawn(function()
			bedwars["BedTable"] = {}
			repeat wait() until matchState ~= 0
			if workspace.MapCFrames:FindFirstChild("1_spawn") then
				antivoidypos = workspace.MapCFrames["1_spawn"].Value.p.Y * 3
			end
			scanforbeds()
		end)
		bedwars["ClientStoreHandler"].changed:connect(function(p3, p4)
			if p3.Game ~= p4.Game then
				if p3.Game.matchState ~= p4.Game.matchState then
					matchState = p3.Game.matchState
					if matchState ~= 0 then
						kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
					end
				end
			end
		end)
		matchState = bedwars["ClientStoreHandler"]:getState().Game.matchState
		if matchState ~= 0 then
			kit = rawget(bedwars["ClientStoreHandler"]:getState()["Bedwars"], "kit")
		end
	else
		wait(1)
	--	print(bedwars["assetTable"],bedwars["ZiplineRemote"],bedwars["HitProjectile"],bedwars["FireProjectile"],bedwars["getInventory"],bedwars["raiseShield"],bedwars["BlockController"],bedwars["BlockEngine"],bedwars["BlockController2"],bedwars["SwordController"],bedwars["attackEntity"],bedwars["damageTable"],bedwars["sprintTable"])
		getfunctions()
	end
end

local function runcode(func)
	func()
end

local function makerandom(min, max)
	return Random.new().NextNumber(Random.new(), min, max)
end

local function getblock(pos)
	return bedwars["BlockEngine2"]:getStore():getBlockAt(bedwars["BlockEngine2"]:getBlockPosition(pos))
end

getfunctions()

local function friendCheck(plr)
	if not robloxfriends[plr.UserId] then
		if lplr:IsFriendsWith(plr.UserId) then
			table.insert(robloxfriends, plr.Name)
			robloxfriends[plr.UserId] = true
		end
	end
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] and ((GuiLibrary["ObjectsThatCanBeSaved"]["Use Roblox FriendsToggle"]["Api"]["Enabled"] and table.find(robloxfriends, plr.Name) == nil) and table.find(GuiLibrary["FriendsObject"]["Friends"], plr.Name) == nil) or GuiLibrary["ObjectsThatCanBeSaved"]["Use FriendsToggle"]["Api"]["Enabled"] == false)
end

shared.vapeteamcheck = function(plr)
	return (GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] and bedwars["PlayerUtil"].getGamePlayer(lplr):getTeamId() ~= bedwars["PlayerUtil"].getGamePlayer(plr):getTeamId() or GuiLibrary["ObjectsThatCanBeSaved"]["Teams by colorToggle"]["Api"]["Enabled"] == false)
end

local function targetCheck(plr, check)
	return (check and plr.Character.Humanoid.Health > 0 and plr.Character:FindFirstChild("ForceField") == nil or check == false)
end

local function isAlive(plr)
	if plr then
		return plr and plr.Character and plr.Character.Parent ~= nil and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Character:FindFirstChild("Head") and plr.Character:FindFirstChild("Humanoid")
	end
	return lplr and lplr.Character and lplr.Character.Parent ~= nil and lplr.Character:FindFirstChild("HumanoidRootPart") and lplr.Character:FindFirstChild("Head") and lplr.Character:FindFirstChild("Humanoid")
end

local localentity = bedwars["getEntityTable"]["getLocalPlayerEntity"]()

local function switchItem(tool)
	lplr.Character.HandInvItem.Value = tool
	bedwars["ClientHandler"]:Get(bedwars["changeItem"]):CallServerAsync({
		hand = tool
	})
end

local function switchToAndUseTool(block, legit)
	local tool = nil
	local toolnum = 0
	local blockmeta = bedwars["getItemMetadata"](block.Name)
	local blockType = ""
	if blockmeta["block"] and blockmeta["block"]["breakType"] then
		blockType = blockmeta["block"]["breakType"]
	end
	for i,v in pairs(bedwars["getInventory"](lplr)["items"]) do
		local meta = bedwars["getItemMetadata"](v["itemType"])
		if meta["breakBlock"] and meta["breakBlock"][blockType] then
			tool = v
			break
		end
	end
	if tool and (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value ~= tool["tool"]) then
		if legit then
			bedwars["ClientStoreHandler"]:dispatch({
				type = "InventorySelectHotbarSlot", 
				slot = getHotbarSlot(tool["itemType"])
			})
		end
		switchItem(tool["tool"])
	end
end

local function getlastblock(pos, normal)
	local lastfound = nil
	for i = 1, 20 do
		local extrablock = getblock(pos + (Vector3.FromNormalId(normal) * (i * 3)))
		if extrablock and extrablock.Parent ~= nil then
			lastfound = extrablock
		else
			break
		end
	end
	return lastfound
end

local healthbarblocktable = {
	["blockHealth"] = -1,
	["breakingBlockPosition"] = Vector3.new(0, 0, 0)
}
bedwars["breakBlock"] = function(pos, effects, normal)
	local block = (getlastblock(pos, Enum.NormalId[normal]) or getblock(pos))
	local olditem = lplr.Character.HandInvItem.Value
	local blockhealthbarpos = {blockPosition = Vector3.new(0, 0, 0)}
	local blockdmg = 0
	if block and block.Parent ~= nil then
		switchToAndUseTool(block)
		blockhealthbarpos = {
			blockPosition = bedwars["BlockEngine2"]:getBlockPosition(block.Position)
		}
		if healthbarblocktable.blockHealth == -1 or blockhealthbarpos.blockPosition ~= healthbarblocktable.breakingBlockPosition then
			healthbarblocktable.blockHealth = block:GetAttribute("Health")
			healthbarblocktable.breakingBlockPosition = blockhealthbarpos.blockPosition
		end
		blockdmg = bedwars["BlockEngine2"]:calculateBlockDamage(lplr, blockhealthbarpos)
		healthbarblocktable.blockHealth = healthbarblocktable.blockHealth - blockdmg
		if healthbarblocktable.blockHealth < 0 then
			healthbarblocktable.blockHealth = 0
		end
		if effects then
			bedwars["BlockHealthbar"]["updateHealthbar"](bedwars["BlockHealthbar2"], blockhealthbarpos, healthbarblocktable.blockHealth, block:GetAttribute("MaxHealth"), blockdmg)
		end
		bedwars["ClientHandlerDamageBlock"]:Get("DamageBlock"):CallServerAsync({
			blockRef = blockhealthbarpos, 
			hitPosition = block.Position, 
			hitNormal = Vector3.FromNormalId(Enum.NormalId[normal])
		}):andThen(function(p9)
			if olditem then
				switchToAndUseTool(olditem)
			end
		end)
		if effects then
			if healthbarblocktable.blockHealth <= 0 then
				bedwars["BlockHealthbar2"].breakEffect:playBreak(block.Name, blockhealthbarpos.blockPosition, lplr)
				bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning()
			else
				bedwars["BlockHealthbar2"].breakEffect:playHit(block.Name, blockhealthbarpos.blockPosition, lplr)
			end
		end
	end
end	

local function getEquipped()
	local type = ""
	local obj = (isAlive() and lplr.Character:FindFirstChild("HandInvItem") and lplr.Character.HandInvItem.Value or nil)
	if obj then
		if obj.Name:find("sword") or obj.Name:find("blade") or obj.Name:find("baguette") then
			type = "sword"
		end
		if obj.Name:find("wool") then
			type = "block"
		end
		if obj.Name:find("bow") then
			type = "bow"
		end
	end
    return {["Object"] = obj, ["Type"] = type}
end

local function nakedcheck(plr)
	local inventory = bedwars["getInventory"](plr)
	return inventory["armor"][4] ~= nil and inventory["armor"][5] ~= nil and inventory["armor"][6] ~= nil
end

local function isPlayerTargetable(plr, target, friend, team)
    return plr ~= lplr and GuiLibrary["ObjectsThatCanBeSaved"]["PlayersToggle"]["Api"]["Enabled"] and plr and isAlive(plr) and targetCheck(plr, target) and (GuiLibrary["ObjectsThatCanBeSaved"]["Ignore nakedToggle"]["Api"]["Enabled"] and nakedcheck(plr) or GuiLibrary["ObjectsThatCanBeSaved"]["Ignore nakedToggle"]["Api"]["Enabled"] == false) and ((team and plr.Team == lplr.Team) or (team == nil and shared.vapeteamcheck(plr)))
end

local function vischeck(pos, pos2, ignore)
	local vistab = cam:GetPartsObscuringTarget({pos, pos2}, ignore)
	for i,v in pairs(vistab) do
		print(i,v:GetFullName())
	end
	return not unpack(vistab)
end

local function GetAllNearestHumanoidToPosition(distance, amount)
	local returnedplayer = {}
	local currentamount = 0
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and currentamount < amount then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= distance then
                    table.insert(returnedplayer, v)
					currentamount = currentamount + 1
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToPosition(distance)
	local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, false) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") then
                local mag = (lplr.Character.HumanoidRootPart.Position - v.Character.HumanoidRootPart.Position).magnitude
                if mag <= closest then
                    closest = mag
                    returnedplayer = v
                end
            end
        end
	end
	return returnedplayer
end

local function GetNearestHumanoidToMouse(distance, checkvis)
    local closest, returnedplayer = distance, nil
    if isAlive() then
        for i, v in pairs(players:GetChildren()) do
            if isPlayerTargetable(v, true, true) and v.Character:FindFirstChild("HumanoidRootPart") and v.Character:FindFirstChild("Head") and (checkvis == false or checkvis and (vischeck(v.Character, "Head") or vischeck(v.Character, "HumanoidRootPart"))) then
                local vec, vis = cam:WorldToScreenPoint(v.Character.HumanoidRootPart.Position)
                if vis then
                    local mag = (uis:GetMouseLocation() - Vector2.new(vec.X, vec.Y)).magnitude
                    if mag <= closest then
                        closest = mag
                        returnedplayer = v
                    end
                end
            end
        end
    end
    return returnedplayer
end

GuiLibrary["RemoveObject"]("AimAssistOptionsButton")

GuiLibrary["RemoveObject"]("AutoClickerOptionsButton")
local oldenable
local olddisable
local blockplacetable = {}
local blockplaceenabled = false
local autoclickercps = {["GetRandomValue"] = function() return 1 end}
local autoclicker = {["Enabled"] = false}
local autoclickertick = tick()
local autoclickerblocks = {["Enabled"] = false}
autoclicker = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("AutoClicker", function()
	oldenable = bedwars["BlockController2"]["enable"]
	olddisable = bedwars["BlockController2"]["disable"]
	bedwars["BlockController2"]["enable"] = function(Self, tab)
		blockplaceenabled = true
		blockplacetable = Self
		return oldenable(Self, tab)
	end
	bedwars["BlockController2"]["disable"] = function(Self)
		blockplaceenabled = false
		return olddisable(Self)
	end
	BindToRenderStep("AutoClicker", 1, function() 
		if isAlive() and uis:IsMouseButtonPressed(0) and autoclickertick <= tick() and bedwars["ClientStoreHandler"]:getState().App.shownApp <= 0 and GuiLibrary["MainGui"].ClickGui.Visible == false and matchState ~= 0 then
			autoclickertick = tick() + (1 / autoclickercps["GetRandomValue"]())
			if getEquipped()["Type"] == "sword" then
				bedwars["SwordController"]["swingSwordAtMouse"](bedwars["SwordController"])
			end
			if blockplaceenabled and autoclickerblocks["Enabled"] then
				local mouseinfo = blockplacetable.clientManager:getBlockSelector():getMouseInfo(0)
				if mouseinfo and getmetatable(bedwars["BlockController"])["isAllowedPlacement"](bedwars["BlockController"], lplr, blockplacetable.blockType, mouseinfo.placementPosition, 0) then
					bedwars["BlockController2"]["placeBlock"](blockplacetable, mouseinfo.placementPosition)
				end
			end
		end
	end)
end, function()
	bedwars["BlockController2"]["enable"] = oldenable
	bedwars["BlockController2"]["disable"] = olddisable
	oldenable = nil
	olddisable = nil
	UnbindFromRenderStep("AutoClicker")
end, true, function() return "" end, "Clicks for you")
autoclickercps = autoclicker.CreateTwoSlider("CPS", 1, 20, function(val) end, false, 8, 12)
autoclickerblocks = autoclicker.CreateToggle("Place Blocks", function() end, function() end, true)

GuiLibrary["RemoveObject"]("ReachOptionsButton")
local oldclick
local reachtping = false
local Reach = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("Reach", function()
	oldclick = bedwars["SwordController"]["swingSwordAtMouse"]
	bedwars["SwordController"]["swingSwordAtMouse"] = function(...)
		if isAlive() then
			local direction = mouse.UnitRay.Direction
			local raycastparameters = RaycastParams.new()
			raycastparameters.FilterDescendantsInstances = {lplr.Character}
			raycastparameters.FilterType = Enum.RaycastFilterType.Blacklist
			local newray = workspace:Raycast(mouse.UnitRay.Origin, direction * 200, raycastparameters)
			if newray.Instance and (lplr.Character.PrimaryPart.Position - newray.Instance.Position).Magnitude <= 16 then
				local mag = (lplr.Character.PrimaryPart.Position - newray.Instance.Position).Magnitude
				print(mag)
				local plr = bedwars["getEntityTable"].getEntity(newray.Instance)
				if mag > 14.4 and plr then
					if reachtping == false then
						local oldcframe = lplr.Character.HumanoidRootPart.CFrame
						reachtping = true
						lplr.Character.HumanoidRootPart.CFrame = oldcframe + (direction * (mag - 14))
						wait(0.05)
						oldclick(...)
						wait(0.1)
						lplr.Character.HumanoidRootPart.CFrame = oldcframe
						reachtping = false
						return nil
					end
				end
			end
		end
		return oldclick(...)
	end
end, function() 
	bedwars["SwordController"]["swingSwordAtMouse"] = oldclick
	oldclick = nil
end, true, function() return "" end, "Works 2% of the time lol")
GuiLibrary["RemoveObject"]("PhaseOptionsButton")
runcode(function()
	local velohorizontal = {["Value"] = 100}
	local velovertical = {["Value"] = 100}
	local oldhori = bedwars["KnockbackTable"]["kbDirectionStrength"]
	local oldvert = bedwars["KnockbackTable"]["kbUpwardStrength"]
	local oldvelo
	local Velocity = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("Velocity", function()
		oldvelo = bedwars["KnockbackTable2"]["applyKnockback"]
		bedwars["KnockbackTable2"]["applyKnockback"] = function(...)
			if velohorizontal["Value"] == 0 then
				return nil
			end
			return oldvelo(...)
		end
		bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori * (velohorizontal["Value"] / 100)
		bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert * (velovertical["Value"] / 100)
	end, function() 
		bedwars["KnockbackTable2"]["applyKnockback"] = oldvelo
		oldvelo = nil
		bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori
		bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert
	end, true, function() return "" end, "Reduces knockback taken")
	velohorizontal = Velocity.CreateSlider("Horizontal", 0, 100, function(val) bedwars["KnockbackTable"]["kbDirectionStrength"] = oldhori * (val / 100) end, 0)
	velovertical = Velocity.CreateSlider("Vertical", 0, 100, function(val) bedwars["KnockbackTable"]["kbUpwardStrength"] = oldvert * (val / 100) end, 0)
end)

runcode(function()
	local oldclick
	local noclickdelay = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("NoClickDelay", function()
		oldclick = bedwars["SwordController"]["isClickingTooFast"]
		bedwars["SwordController"]["isClickingTooFast"] = function() return false end
	end, function() 
		bedwars["SwordController"]["isClickingTooFast"] = oldclick
		oldclick = nil
	end, true, function() return "" end, "Removes Click Delay")
end)

runcode(function()
	local Sprint = {["Enabled"] = false}
	Sprint = GuiLibrary["ObjectsThatCanBeSaved"]["CombatWindow"]["Api"].CreateOptionsButton("Sprint", function()
		spawn(function()
			repeat
				wait()
				if bedwars["sprintTable"].sprinting == false then
					getmetatable(bedwars["sprintTable"])["startSprinting"](bedwars["sprintTable"])
				end
			until Sprint["Enabled"] == false
		end)
	end, function() end, true, function() return "" end, "Sets your sprinting to true")
end)

GuiLibrary["RemoveObject"]("BlinkOptionsButton")
runcode(function()
	local Blink = {["Enabled"] = false}
	Blink = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Blink", function() 
		if GuiLibrary["ObjectsThatCanBeSaved"]["Blatant modeToggle"]["Api"]["Enabled"] then
			settings():GetService("NetworkSettings").IncomingReplicationLag = 99999
		else
			Blink["ToggleButton"](false)
		end
	end, function()
		if GuiLibrary["ObjectsThatCanBeSaved"]["Blatant modeToggle"]["Api"]["Enabled"] then
			settings():GetService("NetworkSettings").IncomingReplicationLag = 0
		end
	end, false, function() return "" end, "Chokes all incoming packets (blatant mode required)\nPlease do not turn this on if you do not know what you are doing.")
end)

runcode(function()
	local antivoidpart
	local antitransparent = {["Enabled"] = false}
	local AntiVoid = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton("AntiVoid", function()
		spawn(function()
			repeat wait() until antivoidypos ~= 0
			antivoidpart = Instance.new("Part")
			antivoidpart.CanCollide = true
			antivoidpart.Size = Vector3.new(10000, 1, 10000)
			antivoidpart.Anchored = true
			antivoidpart.Transparency = (antitransparent["Enabled"] and 1 or 0.5)
			antivoidpart.Position = Vector3.new(0, antivoidypos - 20, 0)
			antivoidpart.Touched:connect(function(touchedpart)
				if touchedpart.Parent == lplr.Character and isAlive() then
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 100, 0)
				end
			end)
			antivoidpart.Parent = game.Workspace
		end)
	end, function() 
		if antivoidpart then
			antivoidpart:Remove() 
		end
	end, true, function() return "" end, "Gives you a chance to get on land (Not Perfect)")
	antitransparent = AntiVoid.CreateToggle("Invisible", function() 
		if antivoidpart then
			antivoidpart.Transparency = 1
		end
	end, function()
		if antivoidpart then
			antivoidpart.Transparency = 0.5
		end
	end, true)
end)


local function getScaffold(vec)
    return Vector3.new(math.floor((vec.X / 3) + 0.5) * 3, math.floor((vec.Y / 3) + 0.5) * 3, math.floor((vec.Z / 3) + 0.5) * 3) 
end

local function scaffoldBlock(newpos)
    bedwars["placeBlock"](newpos)
end

local swords = {
	["wood_sword"] = "stone_sword",
	["stone_sword"] = "iron_sword",
	["iron_sword"] = "diamond_sword",
	["diamond_sword"] = "emerald_sword"
}
local betterswords = {
	["stone_sword"] = 2,
	["iron_sword"] = 3,
	["diamond_sword"] = 4,
	["emerald_sword"] = 5,
}


local function checkallswords()
	local highestsword = 1
	local currentbuyablesword = nil
	for i, v in pairs(betterswords) do
		local NextSwordTable = bedwars["Shop"].getShopItem(i)
		local NextSwordCurrency = getItem(NextSwordTable["currency"])
		if NextSwordCurrency and NextSwordCurrency["amount"] >= NextSwordTable["price"] and highestsword < v then
			highestsword =  v
			currentbuyablesword = i
		end
	end
	return currentbuyablesword
end

local AutoBuy = {["Enabled"] = false}
local AutoBuyArmor = {["Enabled"] = false}
local AutoBuySword = {["Enabled"] = false}
local AutoBuyUpgrades = {["Enabled"] = false}
local AutoBuyGui = {["Enabled"] = false}
local buyingthing = false

local function buyitem(itemtab, sucfunc)
	if getItem(itemtab.itemType) == nil then
		bedwars["ClientHandler"]:Get("BedwarsPurchaseItem"):CallServerAsync({
			shopItem = itemtab
		}):andThen(function(p11)
			if p11 then
				bedwars["SoundManager"]:playSound(12)
				bedwars["ClientStoreHandler"]:dispatch({
					type = "BedwarsAddItemPurchased", 
					itemType = itemtab.itemType
				});
				if itemtab.itemType == "emerald_sword" then
					local sword, swordnum = getSword()
					if sword.itemType ~= "emerald_sword" then
						sword["tool"]:Remove()
						bedwars["getInventory"](lplr)["items"][swordnum] = nil
					end
				end
				if itemtab.nextTier then
					local ShopItems = bedwars["Shop"].ShopItems;
					local function isNextTier(p12)
						return p12.itemType == NextArmorTable.nextTier;
					end;
					local itemToSelect = nil;
					for itemnum, item in ipairs(ShopItems) do
						if isNextTier(item, itemnum - 1, ShopItems) == true then
							itemToSelect = item;
							break;
						end;
					end;
					bedwars["SetSelectedShopItem"](itemToSelect);
					return;
				elseif itemtab.tiered or itemtab.lockAfterPurchase then

				end
				wait(0.3)
				sucfunc()
			end
		end)
	end
end

local BuyCheck = function() end
BuyCheck = function()
	if AutoBuy["Enabled"] then
			local ExecuteInventory = bedwars["getInventory"](lplr)
			local NextArmor = ExecuteInventory.armor[5] and bedwars["Shop"].getShopItem(ExecuteInventory.armor[5].itemType) and bedwars["Shop"].getShopItem(ExecuteInventory.armor[5].itemType)["nextTier"] or (getArmor() == nil and "leather_chestplate" or nil)
			local NextSword = getSword()
			local ProtectionUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "armor")
			local SharpnessUpgrade = bedwars["Shop"].getUpgrade(bedwars["Shop"]["TeamUpgrades"], "damage")
			if AutoBuySword["Enabled"] and NextSword and kit ~= "barbarian" and (AutoBuyGui["Enabled"] and (bedwars["ClientStoreHandler"]:getState().App.shownApp == 5 or bedwars["ClientStoreHandler"]:getState().App.shownApp == 4) or (not AutoBuyGui["Enabled"])) then
				local buyablesword = checkallswords()
				if buyablesword and NextSword and betterswords[buyablesword] > (NextSword.itemType ~= "wood_sword" and betterswords[NextSword.itemType] or 1) then
					local NextSwordTable = bedwars["Shop"].getShopItem(buyablesword)
					buyitem(NextSwordTable, function()
						NextSword = swords[NextSwordTable["itemType"]]
					end)
				end
			end
			if AutoBuyArmor["Enabled"] and NextArmor and (AutoBuyGui["Enabled"] and bedwars["ClientStoreHandler"]:getState().App.shownApp == 5 or (not AutoBuyGui["Enabled"])) then
				local NextArmorTable = bedwars["Shop"].getShopItem(NextArmor)
				local NextArmorCurrency = getItem(NextArmorTable["currency"])
				if NextArmorCurrency and NextArmorCurrency["amount"] >= NextArmorTable["price"] then
					buyitem(NextArmorTable, function()
						NextArmor = NextArmorTable["nextTier"]
					end)
				end
			end
			if AutoBuyUpgrades["Enabled"] and (AutoBuyGui["Enabled"] and bedwars["ClientStoreHandler"]:getState().App.shownApp == 4 or (not AutoBuyGui["Enabled"])) then
				local CurrentUpgrades = bedwars["ClientStoreHandler"]:getState()["Bedwars"]["teamUpgrades"]
				local ProtNewTier = ProtectionUpgrade["tiers"][CurrentUpgrades["armor"] and CurrentUpgrades["armor"] + 2 or 1]
				local SharpNewTier = SharpnessUpgrade["tiers"][CurrentUpgrades["damage"] and CurrentUpgrades["damage"] + 2 or 1]
				if ProtNewTier then
				local ProtCurrency = getItem(ProtNewTier["currency"])
					if ProtCurrency and ProtCurrency["amount"] >= ProtNewTier["price"] then
						bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
							upgradeId = "armor", 
							tier = CurrentUpgrades["armor"] and CurrentUpgrades["armor"] + 1 or 0
						}):andThen(function()
							bedwars["SoundManager"]:playSound(11)
						end)
					end
				end
				if SharpNewTier then
					local SharpCurrency = getItem(SharpNewTier["currency"])
					if SharpCurrency and SharpCurrency["amount"] >= SharpNewTier["price"] then
						bedwars["ClientHandler"]:Get("BedwarsPurchaseTeamUpgrade"):CallServerAsync({
							upgradeId = "damage", 
							tier = CurrentUpgrades["damage"] and CurrentUpgrades["damage"] + 1 or 0
						}):andThen(function()
							bedwars["SoundManager"]:playSound(11)
						end)
					end
				end
			end
	end
end

runcode(function()
	local oldenable2
	local olddisable2
	local oldhitblock
	local blockplacetable2 = {}
	local blockplaceenabled2 = false

	local AutoTool = GuiLibrary["ObjectsThatCanBeSaved"]["WorldWindow"]["Api"].CreateOptionsButton("AutoTool", function()
		oldenable2 = bedwars["BlockHealthbar2"]["enable"]
		olddisable2 = bedwars["BlockHealthbar2"]["disable"]
		oldhitblock = bedwars["BlockHealthbar2"]["hitBlock"]
		bedwars["BlockHealthbar2"]["enable"] = function(Self, tab)
			blockplaceenabled2 = true
			blockplacetable2 = Self
			return oldenable2(Self, tab)
		end
		bedwars["BlockHealthbar2"]["disable"] = function(Self)
			blockplaceenabled2 = false
			return olddisable2(Self)
		end
		bedwars["BlockHealthbar2"]["hitBlock"] = function(...)
			if isAlive() and matchState ~= 0 and blockplaceenabled2 then
				local mouseinfo = blockplacetable2.clientManager:getBlockSelector():getMouseInfo(0)
				if mouseinfo and mouseinfo.target then
					switchToAndUseTool(mouseinfo.target.blockInstance, true)
				end
			end
			return oldhitblock(...)
		end
	end, function() 
		UnbindFromRenderStep("AutoTool")
		bedwars["BlockHealthbar2"]["enable"] = oldenable2
		bedwars["BlockHealthbar2"]["disable"] = olddisable2
		bedwars["BlockHealthbar2"]["hitBlock"] = oldhitblock
		oldenable2 = nil
		olddisable2 = nil
		oldhitblock = nil
	end, true, function()
		return ""
	end, "Automatically swaps your hand to the appropriate tool.")
end)

runcode(function()
	local BedNuker = {["Enabled"] = false}
	local bednukerdigpos = {["Value"] = "Right"}
	local bednukerrange = {["Value"] = 1}
	local bednukereffects = {["Enabled"] = false}
	BedNuker = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("BedNuker", function()
		spawn(function()
			repeat
				wait()
				local tab = bedwars["BedTable"]
				for i = 1, #tab do
					local obj = tab[i]
					if isAlive() then
						if obj and obj:FindFirstChild("Covers") and obj.Covers.BrickColor ~= lplr.Team.TeamColor and obj.Parent ~= nil then
							if (lplr.Character.HumanoidRootPart.Position - obj.Position).magnitude <= bednukerrange["Value"] then
								bedwars["breakBlock"](obj.Position, bednukereffects["Enabled"], bednukerdigpos["Value"])
								wait(0.3)
							end
						end
					end
				end
			until BedNuker["Enabled"] == false
		end)
	end, function() end, true, function()
		return ""
	end, "Automatically destroys beds around you.")
	bednukerdigpos = BedNuker.CreateDropdown("Break Direction", {"Right", "Left", "Front", "Back", "Top", "Bottom"}, function(val) end)
	bednukerrange = BedNuker.CreateSlider("Break range", 1, 20, function(val) end, 20)
	bednukereffects = BedNuker.CreateToggle("Show HealthBar & Effects", function() end, function() bedwars["BlockHealthbar2"].healthbarMaid:DoCleaning() end, true)
end)

bedwars["ClientStoreHandler"].changed:connect(function(p3, p4)
	if p3.Inventory.observedInventory.inventory ~= p4.Inventory.observedInventory.inventory then
		BuyCheck()
	end
end)
bedwars["ClientHandler"]:Get("PickupItemEvent"):Connect(BuyCheck)
AutoBuy = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton("AutoBuy", function() buyingthing = false BuyCheck() end, function() end, true, function() return "" end, "Automatically Buys Swords, Armor, and Team Upgrades.")
AutoBuyArmor = AutoBuy.CreateToggle("Buy Armor", function() end, function() end, true)
AutoBuySword = AutoBuy.CreateToggle("Buy Sword", function() end, function() end, true)
AutoBuyUpgrades = AutoBuy.CreateToggle("Buy Team Upgrades", function() end, function() end, true)
AutoBuyGui = AutoBuy.CreateToggle("Shop GUI Check", function() end, function() end)
GuiLibrary["RemoveObject"]("LongJumpOptionsButton")
GuiLibrary["RemoveObject"]("KillauraOptionsButton")

local spiderparts = {}

local function createpart(pos, ysize, part)
	local truss = Instance.new("TrussPart")
	truss.Size = Vector3.new(2, ysize, 2)
	truss.Name = "spiderman"
	truss.Position = (part.Position - (part.Size / 2)) + Vector3.new(math.clamp(pos.X, 0,  part.Size.X - 1), math.clamp(pos.Y, 0, part.Size.Y), math.clamp(pos.Z, 0, part.Size.Z - 1))
	truss.Transparency = 1
	truss.Anchored = true
	truss.Parent = part
	table.insert(spiderparts, truss)
	return truss
end

runcode(function()
	local spiderconnection
	local cando = true
	local Spider = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Spider", function()
		if cando and #spiderparts <= 0 then
			cando = false
			spiderconnection = workspace.Map.Blocks.ChildAdded:connect(function(v)
				for i3 = 1, v.Size.Z + 1 do
					for i2 = 1, v.Size.X + 1 do
						createpart(Vector3.new(i2, v.Size.Y / 2, i3), v.Size.Y, v)
					end
				end
			end)
			spawn(function()
				repeat wait() until matchState ~= 0
				local spidermessage = Instance.new("TextLabel")
				spidermessage.Size = UDim2.new(1, 0, 0, 36)
				spidermessage.Text = "Parts Processed : 0"
				spidermessage.BackgroundTransparency = 1
				spidermessage.TextStrokeTransparency = 0
				spidermessage.TextSize = 30
				spidermessage.Font = Enum.Font.SourceSans
				spidermessage.TextColor3 = Color3.new(1, 1, 1)
				spidermessage.Position = UDim2.new(0, 0, 0, -36)
				spidermessage.Parent = GuiLibrary["MainGui"]
				local tempblocks = workspace.Map.Blocks:GetChildren()
				for i,v in pairs(tempblocks) do
					spidermessage.Text = "Parts Processed : "..tostring(i).."/"..tostring(#tempblocks)
					if i % 100 == 0 then
						wait(0.4)
					end
					for i3 = 1, v.Size.Z + 1 do
						for i2 = 1, v.Size.X + 1 do
							createpart(Vector3.new(i2, v.Size.Y / 2, i3), v.Size.Y, v)
						end
					end
				end
				spidermessage:Remove()
				cando = true
			end)
		end
	end, function()
		if cando then
			cando = false
			if spiderconnection then
				spiderconnection:Disconnect()
			end
			spawn(function()
				local spidermessage = Instance.new("TextLabel")
				spidermessage.Size = UDim2.new(1, 0, 0, 36)
				spidermessage.Text = "Spider Parts Removed : 0"
				spidermessage.BackgroundTransparency = 1
				spidermessage.TextStrokeTransparency = 0
				spidermessage.TextSize = 30
				spidermessage.Font = Enum.Font.SourceSans
				spidermessage.TextColor3 = Color3.new(1, 1, 1)
				spidermessage.Position = UDim2.new(0, 0, 0, -36)
				spidermessage.Parent = GuiLibrary["MainGui"]
				for i,v in pairs(spiderparts) do
					spidermessage.Text = "Spider Parts Removed : "..tostring(i).."/"..tostring(#spiderparts)
					if i % 10000 == 0 then
						wait(0.4)
					end
					v:Remove()
				end
				cando = true
				spidermessage:Remove()
				spiderparts = {}
			end)
		end
	end, true, function() return "" end, "Lets you climb up walls after the lagspike.")
end)

runcode(function()
	local OpenShop = {["Enabled"] = false}
	OpenShop = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton("OpenShop", function()
		bedwars["SoundManager"]:playSound(4)
		bedwars["ClientStoreHandler"]:dispatch({
			type = "SetShownApp", 
			app = 5
		})
		OpenShop["ToggleButton"](false)
	end, function() end, true, function() return "" end, "Opens the Shop GUI")

	local OpenTeamUpgrades = {["Enabled"] = false}
	OpenTeamUpgrades = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton("OpenTeamUpgrades", function()
		bedwars["SoundManager"]:playSound(4)
		bedwars["ClientStoreHandler"]:dispatch({
			type = "SetShownApp", 
			app = 4
		})
		OpenTeamUpgrades["ToggleButton"](false)
	end, function() end, true, function() return "" end, "Opens the Team Upgrade GUI")
end)

local killaurabox = Instance.new("BoxHandleAdornment")
killaurabox.Transparency = 0.5
killaurabox.Color3 = Color3.new(1, 0, 0)
killaurabox.Adornee = nil
killaurabox.AlwaysOnTop = true
killaurabox.ZIndex = 11
killaurabox.Parent = GuiLibrary["MainGui"]
local killauraanimmethod = {["Value"] = "Normal"}
local killauraaps = {["GetRandomValue"] = function() return 1 end}
local killaurarange = {["Value"] = 14}
local killauraangle = {["Value"] = 360}
local killauratargets = {["Value"] = 10}
local killauramouse = {["Enabled"] = false}
local killauracframe = {["Enabled"] = false}
local killauraautoblock = {["Enabled"] = false}
local killauragui = {["Enabled"] = false}
local killauratarget = {["Enabled"] = false}
local killaurasound = {["Enabled"] = false}
local killauraswing = {["Enabled"] = false}
local killaurahandcheck = {["Enabled"] = false}
local killaurabaguette = {["Enabled"] = false}
local killauraanimation = {["Enabled"] = false}
local Killaura = {["Enabled"] = false}
local killauradelay = 0
local Killauranear = false
local killauraplaying = false
local oldplay = function() end
local oldsound = function() end
local oldmeta
Killaura = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Killaura", function()
	oldplay = bedwars["ViewmodelController"]["playAnimation"]
	oldsound = bedwars["SoundManager"]["playSound"]
	oldmeta = bedwars["SwordController"]["getHandItem"]
	bedwars["SwordController"]["getHandItem"] = function(Self)
		if (not killaurahandcheck["Enabled"]) then
			if killaurabaguette["Enabled"] and getBaguette() then
				return getBaguette()
			else
				return getSword()
			end
		else
			return oldmeta(Self)
		end
	end
	bedwars["SoundManager"]["playSound"] = function(tab, soundid, ...)
		if (soundid == 13 or soundid == 14) and Killaura["Enabled"] and killaurasound["Enabled"] and killauranear then
			return nil
		end
		return oldsound(tab, soundid, ...)
	end
	bedwars["ViewmodelController"]["playAnimation"] = function(Self, id, ...)
		if id == 5 and killauranear and killauraswing["Enabled"] and isAlive() then
			return nil
		end
		if id == 5 and killauranear and killauraanimation["Enabled"] and isAlive() then
			pcall(function()
				if origC0 == nil then
					origC0 = cam.Viewmodel.RightHand.RightWrist.C0
				end
				if killauraplaying == false then
					killauraplaying = true
					game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new((killauraanimmethod["Value"] == "Normal" and 0.1 or 0.2)), {C0 = origC0 * CFrame.new(0.7, -1, 0.6) * CFrame.Angles(-math.rad(45), math.rad(55), -math.rad(70))}):Play()
					wait((killauraanimmethod["Value"] == "Normal" and 0.05 or 0.1))
					game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new((killauraanimmethod["Value"] == "Normal" and 0.1 or 0.2)), {C0 = origC0 * CFrame.new(0.7, -1, 0.6) * CFrame.Angles(-math.rad(45), math.rad(105), -math.rad(70))}):Play()
					wait((killauraanimmethod["Value"] == "Normal" and 0.05 or 0.1))
					killauraplaying = false
				end
			end)
			return nil
		end
		return oldplay(Self, id, ...)
	end
	BindToRenderStep("Killaura", 1, function() 
		local targettable = {}
		local targetsize = 0
		if (killauradelay <= tick()) and matchState ~= 0 then
			local plrs = GetAllNearestHumanoidToPosition(killaurarange["Value"] + 0.4, killauratargets["Value"])
			if #plrs <= 0 then
				killauranear = false
				if killaurabox.Adornee ~= nil then
					killaurabox.Adornee = nil
				end
				pcall(function()
					if origC0 == nil then
						origC0 = cam.Viewmodel.RightHand.RightWrist.C0
					end
					if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
						game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
					end
				end)
			end
			if #plrs > 0 then
				killauradelay = tick() + (1 / killauraaps["GetRandomValue"]())
			end
			for i,plr in pairs(plrs) do
				if isAlive() and (killaurahandcheck["Enabled"] and getEquipped()["Type"] == "sword" or (not killaurahandcheck["Enabled"])) and ((not killaurawall["Enabled"]) and bedwars["SwordController"]["canSee"](bedwars["SwordController"], {["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}) or killaurawall["Enabled"]) and (killauramouse["Enabled"] and uis:IsMouseButtonPressed(0) or (not killauramouse["Enabled"])) and (killauragui["Enabled"] and (bedwars["ClientStoreHandler"]:getState().App.shownApp <= 0 and GuiLibrary["MainGui"].ClickGui.Visible == false) or (not killauragui["Enabled"])) then
					if plr.Character.PrimaryPart and lplr.Character.PrimaryPart then
						killauranear = true
						if killauraautoblock["Enabled"] and kit == "shielder" then
							spawn(bedwars["raiseShield"])
						end
						if killauracframe["Enabled"] then
							lplr.Character:SetPrimaryPartCFrame(CFrame.new(lplr.Character.PrimaryPart.Position, Vector3.new(plr.Character:FindFirstChild("HumanoidRootPart").Position.X, lplr.Character.PrimaryPart.Position.Y, plr.Character:FindFirstChild("HumanoidRootPart").Position.Z)))
						end
						if killauratarget["Enabled"] then
							local ori, size = plr.Character:GetBoundingBox()
							killaurabox.Adornee = (killauratarget["Enabled"] and plr.Character or nil)
							killaurabox.Size = size + Vector3.new(.01, .01, .01)
						end
						targettable[plr.Name] = {
							["UserId"] = plr.UserId,
							["Health"] = (plr.Character and plr.Character.Humanoid and plr.Character.Humanoid.Health or 0),
							["MaxHealth"] = (plr.Character and plr.Character.Humanoid and plr.Character.Humanoid.MaxHealth or 0)
						}
						targetsize = targetsize + 1
						spawn(function()
							bedwars["attackEntity"](bedwars["SwordController"], {["instance"] = plr.Character, ["player"] = plr, ["getInstance"] = function() return plr.Character end}, Ray.new(cam.CFrame.p, plr.Character.HumanoidRootPart.Position).Unit.Direction)	
						end)
					end
				else
					if killaurabox.Adornee ~= nil then
						killaurabox.Adornee = nil
					end
					killauranear = false
					pcall(function()
						if origC0 == nil then
							origC0 = cam.Viewmodel.RightHand.RightWrist.C0
						end
						if cam.Viewmodel.RightHand.RightWrist.C0 ~= origC0 then
							game:GetService("TweenService"):Create(cam.Viewmodel.RightHand.RightWrist, TweenInfo.new(0.1), {C0 = origC0}):Play()
						end
					end)
				end
			end
			if getEquipped()["Type"] ~= "bow" then
				targetinfo.UpdateInfo(targettable, targetsize)
			end
		end
	end)
end, function() 
	killauranear = false
	bedwars["ViewmodelController"]["playAnimation"] = oldplay
	bedwars["SoundManager"]["playSound"] = oldsound
	oldplay = nil
	pcall(function()
		cam.Viewmodel.RightHand.RightWrist.C0 = origC0
	end)
	UnbindFromRenderStep("Killaura") 
	bedwars["SwordController"]["getHandItem"] = oldmeta
	oldmeta = nil
end, true, function()
	return ""
end, "Attack players around you\nwithout aiming at them.\nAutoBlock requires Inferno Shielder")
killauraaps = Killaura.CreateTwoSlider("Attacks per Second", 1, 20, function(val) end, false, 19, 20)
killaurarange = Killaura.CreateSlider("Attack range", 1, 14, function(val) end, 14)
killauraangle = Killaura.CreateSlider("Max angle", 1, 360, function(val) end, 360)
killauratargets = Killaura.CreateSlider("Max targets", 1, 10, function(val) end, 10)
killauraanimmethod = Killaura.CreateDropdown("Animation", {"Normal", "Slow"}, function(val) end)
killauraautoblock = Killaura.CreateToggle("AutoBlock", function() end, function() end, true)
killaurawall = Killaura.CreateToggle("Attack through walls", function() end, function() end, true)
killauramouse = Killaura.CreateToggle("Require mouse down", function() end, function() end, false)
killauragui = Killaura.CreateToggle("GUI Check", function() end, function() end)
killauratarget = Killaura.CreateToggle("Show target", function() end, function() end)
killauracframe = Killaura.CreateToggle("Face target", function() end, function() end)
killaurasound = Killaura.CreateToggle("No Swing Sound", function() end, function() end)
killauraswing = Killaura.CreateToggle("No Swing", function() end, function() end)
killaurahandcheck = Killaura.CreateToggle("Limit to items", function() end, function() end)
killaurabaguette = Killaura.CreateToggle("Baguette Aura", function() end, function() end)
killauraanimation = Killaura.CreateToggle("Custom Animation", function() end, function() end)

local FastPickupRange = {["Value"] = 1}
local FastPickup = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("FastPickup", function()
	BindToRenderStep("FastPickup", 1, function()
		local itemdrops = collectionservice:GetTagged("ItemDrop")
		if isAlive() then
			for i,v in pairs(itemdrops) do
				if (lplr.Character.HumanoidRootPart.Position - v.Position).magnitude <= FastPickupRange["Value"] then
					bedwars["ClientHandler"]:Get(bedwars["PickupRemote"]):CallServerAsync({
						itemDrop = v
					}):andThen(function(p14)
						if p14 then
							bedwars["SoundManager"]:playSound(8)
						end
					end)
				end
			end
		end
	end)
end, function() 
	UnbindFromRenderStep("FastPickup")
end, true)
FastPickupRange = FastPickup.CreateSlider("Range", 1, 10, function() end, 10)

local AutoToxic = {["Enabled"] = false}
local AutoToxicGG = {["Enabled"] = false}
local AutoToxicWin = {["Enabled"] = false}
local AutoToxicDeath = {["Enabled"] = false}
local AutoToxicFinalKill = {["Enabled"] = false}
local AutoToxicWinStreak = {["Enabled"] = false}
local AutoToxicAd = {["Enabled"] = false}
local AutoToxicPhrases = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicPhrases2 = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicPhrases3 = {["RefreshValues"] = function() end, ["ObjectList"] = {}}
local AutoToxicOldWin = bedwars["VictoryScreen"].render
local victorysaid = false
local lastsaid = ""
bedwars["VictoryScreen"].render = function(winstuff)
    local myTeam = bedwars["ClientStoreHandler"]:getState().Game.myTeam
    if myTeam and myTeam.id == winstuff.props.WinningTeamId and victorysaid == false then
		victorysaid = true
		if AutoToxic["Enabled"] then
			if AutoToxicGG["Enabled"] then
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("gg", "All")
			end
			if AutoToxicWin["Enabled"] then
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(#AutoToxicPhrases["ObjectList"] > 0 and AutoToxicPhrases["ObjectList"][math.random(1, #AutoToxicPhrases["ObjectList"])] or "EZ L TRASH KIDS"..(AutoToxicAd["Enabled"] and " : Sponsored by Vape V4 :)" or ""), "All")
			end
		end
    end
    return AutoToxicOldWin(winstuff)
end

local AutoArmor = {["Enabled"] = false}
AutoArmor = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("AutoArmor", function()
	AutoArmor["ToggleButton"](false)
	if localentity == nil then
		localentity = bedwars["getEntityTable"]["getLocalPlayerEntity"]()
	end
	if isAlive() and getArmor() then
		local inv = bedwars["getInventory"](lplr)
		for i5, v5 in pairs(inv["items"]) do
			if v5["itemType"]:match("helmet") then
				localentity.equipArmorItem(localentity, v5["tool"], 0)
				bedwars["ClientStoreHandler"]:dispatch({
					type = "InventorySetArmorItem", 
					item = v5, 
					armorSlot = 0
				})
				bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.inventory.items[i5 + 1] = nil
			elseif v5["itemType"]:match("chestplate") then
				localentity.equipArmorItem(localentity, v5["tool"], 1)
				bedwars["ClientStoreHandler"]:dispatch({
					type = "InventorySetArmorItem", 
					item = v5, 
					armorSlot = 1
				})
				bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.inventory.items[i5 + 1] = nil
			elseif v5["itemType"]:match("boots") then
				localentity.equipArmorItem(localentity, v5["tool"], 2)
				bedwars["ClientStoreHandler"]:dispatch({
					type = "InventorySetArmorItem", 
					item = v5, 
					armorSlot = 2
				})
				bedwars["ClientStoreHandler"]:getState().Inventory.observedInventory.inventory.items[i5 + 1] = nil
			end
		end
	end
end, function() end, true, function() return "" end, "Automatically equips armor on toggle.")

local AutoLeave = {["Enabled"] = false}
local autoleaveconnection

bedwars["ClientHandler"]:OnEvent("MatchEndEvent", function(p2)
	if AutoLeave["Enabled"] then
		bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
	end
end)
AutoLeave = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("AutoLeave", function()
	autoleaveconnection = players.PlayerAdded:connect(function(plr)
		if plr:IsInGroup(5774246) and plr:GetRankInGroup(5774246) >= 100 then
			bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
		end
	end)
	for i, plr in pairs(players:GetChildren()) do
		if plr:IsInGroup(5774246) and plr:GetRankInGroup(5774246) >= 100 then
			bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
		end
	end
end, function() 
	autoleaveconnection:Disconnect()
end, true, function() return "" end, "Leaves if a staff member joins your game or when the match ends.")

if GuiLibrary["Settings"]["ToxicObject"] == nil then
	GuiLibrary["Settings"]["ToxicObject"] = {["Type"] = "Custom", ["List"] = {}}
end
if GuiLibrary["Settings"]["ToxicObject2"] == nil then
	GuiLibrary["Settings"]["ToxicObject2"] = {["Type"] = "Custom", ["List"] = {}}
end
if GuiLibrary["Settings"]["ToxicObject3"] == nil then
	GuiLibrary["Settings"]["ToxicObject3"] = {["Type"] = "Custom", ["List"] = {}}
end

bedwars["ClientHandler"]:WaitFor("EntityDeathEvent"):andThen(function(p6)
	p6:Connect(function(p7)
		if AutoToxic["Enabled"] then
			if p7.fromEntity and p7.fromEntity == lplr.Character then
				local plr = players:GetPlayerFromCharacter(p7.entityInstance)
				if plr and plr.leaderstats.Bed.Value ~= "" and AutoToxicFinalKill["Enabled"] then
					local custommsg = #AutoToxicPhrases2["ObjectList"] > 0 and AutoToxicPhrases2["ObjectList"][math.random(1, #AutoToxicPhrases2["ObjectList"])]
					if custommsg == lastsaid then
						custommsg = #AutoToxicPhrases2["ObjectList"] > 0 and AutoToxicPhrases2["ObjectList"][math.random(1, #AutoToxicPhrases2["ObjectList"])]
					else
						lastsaid = custommsg
					end
					local winstreak = (players:GetPlayerFromCharacter(p7.entityInstance):GetAttribute("WinStreak") > 0 and players:GetPlayerFromCharacter(p7.entityInstance):GetAttribute("WinStreak"))
					if custommsg then
						custommsg = custommsg:gsub("<name>", (plr.DisplayName or plr.Name))
						custommsg = custommsg:gsub("<ws>", winstreak or "0")
					end
					local msg = custommsg or "L "..(plr.DisplayName or plr.Name)..(AutoToxicWinStreak["Enabled"] and winstreak and " : "..winstreak.." winstreak" or "")
					game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
				end
			end
		end
	end)
end)	

bedwars["ClientStoreHandler"].changed:connect(function(p3, p4)
	if p3.Game.spectating and not p4.Game.spectating then
		if AutoToxic["Enabled"] and AutoToxicDeath["Enabled"] then
			game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(#AutoToxicPhrases3["ObjectList"] > 0 and AutoToxicPhrases3["ObjectList"][math.random(1, #AutoToxicPhrases3["ObjectList"])] or "My gaming chair expired midfight.", "All")
		end
		if AutoLeave["Enabled"] then
			wait(1)
			bedwars["ClientHandler"]:Get("TeleportToLobby"):SendToServer()
		end
	end
end)

AutoToxic = GuiLibrary["ObjectsThatCanBeSaved"]["UtilityWindow"]["Api"].CreateOptionsButton("AutoToxic", function() end, function() end, true)
AutoToxicGG = AutoToxic.CreateToggle("AutoGG", function() end, function() end, true)
AutoToxicWin = AutoToxic.CreateToggle("Win", function() end, function() end, true)
AutoToxicDeath = AutoToxic.CreateToggle("Death", function() end, function() end, true)
AutoToxicFinalKill = AutoToxic.CreateToggle("Final Kill", function() end, function() end, true)
AutoToxicWinStreak = AutoToxic.CreateToggle("WinStreak", function() end, function() end, false)
AutoToxicAd = AutoToxic.CreateToggle("Sponsor", function() end, function() end, false)
AutoToxicPhrases = AutoToxic.CreateTextList("ToxicList", "phrase (win)", function(user) end, function(num) end)
AutoToxicPhrases2 = AutoToxic.CreateTextList("ToxicList2", "phrase (kill) <name> <ws>", function(user) end, function(num) end)
AutoToxicPhrases3 = AutoToxic.CreateTextList("ToxicList3", "phrase (death)", function(user) end, function(num) end)

GuiLibrary["RemoveObject"]("HitBoxesOptionsButton")
GuiLibrary["RemoveObject"]("SpeedOptionsButton")
local fly = {["Enabled"] = false}
local speedval = {["Value"] = 1}
local speedjump = {["Enabled"] = false}
local bodyvelo
local Scaffold = {["Enabled"] = false}
local speed = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Speed", function()
	if fly["Enabled"] then
		createwarning("Speed Stopped", "Disable fly to move.", 4)
	end
	BindToRenderStep("Speed", 1, function(delta)
		if isAlive() and matchState ~= 0 then
			local jumpcheck = speedjump["Enabled"] and killauranear and (not Scaffold["Enabled"])
			if (bodyvelo == nil or bodyvelo ~= nil and bodyvelo.Parent ~= lplr.Character.HumanoidRootPart) then
				bodyvelo = Instance.new("BodyVelocity")
				bodyvelo.Parent = lplr.Character.HumanoidRootPart
				bodyvelo.MaxForce = Vector3.new(100000, 0, 100000)
			else
				bodyvelo.Velocity = lplr.Character.Humanoid.MoveDirection * ((fly["Enabled"] and 0 or speedval["Value"]) * (jumpcheck and 1.15 or 1))
			end
			if lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Climbing then
				bodyvelo.MaxForce = Vector3.new(0, 0, 0)
			else
				bodyvelo.MaxForce = Vector3.new(100000, 0, 100000)
			end
			if jumpcheck then
				if (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics) and lplr.Character.Humanoid.MoveDirection ~= Vector3.new(0, 0, 0) then
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(lplr.Character.HumanoidRootPart.Velocity.X, 20, lplr.Character.HumanoidRootPart.Velocity.Z)
				end
			end
		end
	end)
end, function() 
	if bodyvelo then
		bodyvelo:Remove()
	end
	UnbindFromRenderStep("Speed")
end, true, function() return "" end, "Increases your movement.")
speedval = speed.CreateSlider("Speed", 1, 30, function(val) end, 30)
speedjump = speed.CreateToggle("AutoJump", function() end, function() end)

GuiLibrary["RemoveObject"]("FlyOptionsButton")
local OldNoFallFunction
local flyspeed = {["Value"] = 40}
local flyverticalspeed = {["Value"] = 40}
local flyupanddown = {["Enabled"] = true}
local flybuyballoon = {["Enabled"] = true}
local olddeflate
local flyposy = 0
local flyrequests = 0
local flytime = 60
local flylimit = false
local flyup = false
local flydown = false
local flypress
local flyendpress

local function buyballoons()
	if isAlive() and fly["Enabled"] then
		if getItem("balloon") == nil and flybuyballoon["Enabled"] then
			bedwars["ClientHandler"]:Get("BedwarsPurchaseItem"):CallServerAsync({
				shopItem = bedwars["Shop"].getShopItem("balloon")
			}):andThen(function(p11)
				if getItem("balloon") then
					bedwars["BalloonController"]["inflateBalloon"]()
				end
			end)
		end
		if getItem("balloon") then
			bedwars["BalloonController"]["inflateBalloon"]()
		end
	end
end

bedwars["ClientHandler"]:WaitFor("BalloonPopped"):andThen(function(p6)
	p6:Connect(function(p7)
		buyballoons()
	end)
end)

fly = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Fly", function()
	olddeflate = bedwars["BalloonController"]["deflateBalloon"]
	bedwars["BalloonController"]["deflateBalloon"] = function() end
	if isAlive() then
		spawn(function()
			flyposy = lplr.Character.HumanoidRootPart.Position.Y
			repeat wait() flyposy = lplr.Character.HumanoidRootPart.Position.Y until flyposy == lplr.Character.HumanoidRootPart.Position.Y
			buyballoons()
		end)
	end
	flypress = game:GetService("UserInputService").InputBegan:connect(function(input1)
		if flyupanddown["Enabled"] and game:GetService("UserInputService"):GetFocusedTextBox() == nil then
			if input1.KeyCode == Enum.KeyCode.Space then
				flyup = true
			end
			if input1.KeyCode == Enum.KeyCode.LeftShift then
				flydown = true
			end
		end
	end)
	flyendpress = game:GetService("UserInputService").InputEnded:connect(function(input1)
		if input1.KeyCode == Enum.KeyCode.Space then
			flyup = false
		end
		if input1.KeyCode == Enum.KeyCode.LeftShift then
			flydown = false
		end
	end)
	BindToRenderStep("Fly", 1, function(delta) 
		if isAlive() and matchState ~= 0 then
			if (lplr.Character:GetAttribute("InflatedBalloons") and lplr.Character:GetAttribute("InflatedBalloons") > 0) then
				if flyup then
					flyposy = flyposy + (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
				end
				if flydown then
					flyposy = flyposy - (1 * (math.clamp(flyverticalspeed["Value"] - 16, 1, 150) * delta))
				end
				local flypos = (lplr.Character.Humanoid.MoveDirection * (math.clamp(flyspeed["Value"] - 16, 1, 150) * delta))
				lplr.Character.HumanoidRootPart.Transparency = 1
				lplr.Character.HumanoidRootPart.CFrame = lplr.Character.HumanoidRootPart.CFrame + Vector3.new(flypos.X, (flyposy - lplr.Character.HumanoidRootPart.CFrame.p.Y), flypos.Z)
				lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 0, 0)
			end
		end
	end)
end, function() 
	flyup = false
	flydown = false
	flypress:Disconnect()
	flyendpress:Disconnect()
	UnbindFromRenderStep("Fly")
	if isAlive() and lplr.Character:GetAttribute("InflatedBalloons") then
		for i = 1, lplr.Character:GetAttribute("InflatedBalloons") do
			olddeflate()
		end
	end
	bedwars["BalloonController"]["deflateBalloon"] = olddeflate
	olddeflate = nil
end, true, function() return "" end, "Makes you go zoom (Balloons Required) (Will Buy Balloons)")
flyspeed = fly.CreateSlider("Speed", 1, 40, function(val) end, 40)
flyverticalspeed = fly.CreateSlider("Vertical Speed", 1, 40, function(val) end, 40)
flyupanddown = fly.CreateToggle("Y Level", function() end, function() end, true)
flybuyballoon = fly.CreateToggle("Buy Balloons", function() end, function() end, true)


local oldpos = Vector3.new(0, 0, 0)
local oldpos2 = Vector3.new(0, 0, 0)
local scaffoldtext = Instance.new("TextLabel")
scaffoldtext.Font = Enum.Font.SourceSans
scaffoldtext.TextSize = 20
scaffoldtext.BackgroundTransparency = 1
scaffoldtext.TextColor3 = Color3.fromRGB(255, 0, 0)
scaffoldtext.Size = UDim2.new(0, 0, 0, 0)
scaffoldtext.Position = UDim2.new(0.5, 0, 0.5, 30)
scaffoldtext.Text = "0"
scaffoldtext.Visible = false
scaffoldtext.Parent = GuiLibrary["MainGui"]
local ScaffoldExpand = {["Value"] = 1}
local ScaffoldTower = {["Enabled"] = false}
local ScaffoldStopMotion = {["Enabled"] = false}
local ScaffoldBlockCount = {["Enabled"] = false}
local ScaffoldHandCheck = {["Enabled"] = false}
local ScaffoldBuyBlocks = {["Enabled"] = false}
local scaffoldstopmotionval = false
local scaffoldallowed = true

local scaffoldstopmotionpos = Vector3.new(0, 0, 0)

Scaffold = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("Scaffold", function()
	scaffoldtext.Visible = ScaffoldBlockCount["Enabled"]
	BindToRenderStep("Scaffold", 1, function(delta)
		if isAlive() and (ScaffoldHandCheck["Enabled"] and getEquipped()["Type"] == "block" or (not ScaffoldHandCheck["Enabled"])) then
			if uis:IsKeyDown(Enum.KeyCode.Space) then
				if scaffoldstopmotionval == false then
					scaffoldstopmotionval = true
					scaffoldstopmotionpos = lplr.Character.HumanoidRootPart.CFrame.p
				end
			else
				scaffoldstopmotionval = false
			end
			if getwool() then
				if ScaffoldTower["Enabled"] and uis:IsKeyDown(Enum.KeyCode.Space) and lplr.Character.HumanoidRootPart.CFrame.p.Y < scaffoldypos then
					lplr.Character.HumanoidRootPart.Velocity = Vector3.new(0, 50, 0)
					if ScaffoldStopMotion["Enabled"] and scaffoldstopmotionval then
						lplr.Character.HumanoidRootPart.CFrame = CFrame.new(Vector3.new(scaffoldstopmotionpos.X, lplr.Character.HumanoidRootPart.CFrame.p.Y, scaffoldstopmotionpos.Z))
					end
				end
			end
			for i = 1, ScaffoldExpand["Value"] do
				local newpos = getScaffold((lplr.Character.Head.Position + ((scaffoldstopmotionval == false and lplr.Character.Humanoid.MoveDirection or Vector3.new(0, 0, 0)) * (i * 3.5))) + Vector3.new(0, -math.floor(lplr.Character.Humanoid.HipHeight * 3), 0))
				newpos = Vector3.new(newpos.X, math.clamp(newpos.Y, -999, scaffoldypos), newpos.Z)
				if newpos ~= oldpos then
					local wool, woolamount = getwool()
					scaffoldtext.Text = (woolamount and tostring(woolamount) or "0")
					if woolamount then
						if woolamount >= 128 then
							scaffoldtext.TextColor3 = Color3.fromRGB(9, 255, 198)
						elseif woolamount >= 64 then
							scaffoldtext.TextColor3 = Color3.fromRGB(255, 249, 18)
						else
							scaffoldtext.TextColor3 = Color3.fromRGB(255, 0, 0)
						end
					end
					if ScaffoldBuyBlocks["Enabled"] and (wool and woolamount < 4 or (not wool)) and scaffoldallowed == true then
						if (lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.Running or lplr.Character.Humanoid:GetState() == Enum.HumanoidStateType.RunningNoPhysics) then
							scaffoldallowed = false
							lplr.Character.HumanoidRootPart.Anchored = true
						end
						bedwars["ClientHandler"]:Get("BedwarsPurchaseItem"):CallServerAsync({
							shopItem = bedwars["Shop"].getShopItem("wool_white")
						}):andThen(function(p11)
							scaffoldallowed = true
						end)
					end
					if getwool() then
						lplr.Character.HumanoidRootPart.Anchored = false
						scaffoldBlock(newpos)
						oldpos = newpos
					end
				end
			end
		end
	end)
end, function()
	scaffoldtext.Visible = false
	UnbindFromRenderStep("Scaffold")
	scaffoldallowed = true
	oldpos = Vector3.new(0, 0, 0)
	oldpos2 = Vector3.new(0, 0, 0)
	if isAlive() then
		lplr.Character.HumanoidRootPart.Anchored = false
	end
end, true, function() return "" end, "Helps you make bridges/scaffold walk.")
ScaffoldExpand = Scaffold.CreateSlider("Expand", 1, 8, function(val) end, 1)
ScaffoldTower = Scaffold.CreateToggle("Tower", function() 
	if ScaffoldStopMotion["Object"] then
		ScaffoldStopMotion["Object"].Visible = true 
	end
end, function() 
	if ScaffoldStopMotion["Object"] then
		ScaffoldStopMotion["Object"].Visible = false
	end
end)
ScaffoldStopMotion = Scaffold.CreateToggle("Stop Motion", function() end, function() end)
ScaffoldStopMotion["Object"].BackgroundTransparency = 0
ScaffoldStopMotion["Object"].BorderSizePixel = 0
ScaffoldStopMotion["Object"].BackgroundColor3 = Color3.fromRGB(20, 20, 20)
ScaffoldStopMotion["Object"].Visible = ScaffoldTower["Enabled"]
ScaffoldBlockCount = Scaffold.CreateToggle("Block Count", function() 
	if Scaffold["Enabled"] then
		scaffoldtext.Visible = true 
	end
end, function() 
	if Scaffold["Enabled"] then
		scaffoldtext.Visible = false 
	end
end)
ScaffoldHandCheck = Scaffold.CreateToggle("Whitelist Only", function() end, function() end)
ScaffoldBuyBlocks = Scaffold.CreateToggle("Buy Blocks", function() end, function() end)



--local BuyArrows = {["Enabled"] = false}
--local BowAura = {["Enabled"] = false}
--local bowaurarange = {["Value"] = 50}
--local BowDelay2 = {["Value"] = 5}
--local BowTargets = {["Value"] = 1}
--BowAura = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("BowAura", function()
	--spawn(function()
		--repeat
		--	wait(BowDelay2["Value"] / 10)
		--	if isAlive() and getEquipped()["Type"] == "bow" then
			--	local targettable = {}
			--	local targetsize = 0
			--	local plrs = GetAllNearestHumanoidToPosition(bowaurarange["Value"], BowTargets["Value"])
			--	for i,v in pairs(plrs) do
			--		wait(0.03)
			--		local bowpos = bedwars["ProjectilePosition"]()
				--	if isPlayerTargetable(v, true, true) and v.Character and v.Character:FindFirstChild("Head") and vischeck(bowpos, v.Character.Head.Position, {lplr.Character, v.Character}) then
			--			targettable[v.Name] = {
				--			["UserId"] = v.UserId,
				--			["Health"] = v.Character.Humanoid.Health,
				--			["MaxHealth"] = v.Character.Humanoid.MaxHealth
					--	}
					--	targetsize = targetsize + 1
					--	game:GetService("ReplicatedStorage").rbxts_include.node_modules.net.out._NetManaged[bedwars["FireProjectile"]]:InvokeServer(getEquipped()["Object"], bowpos, (bowpos - v.Character.Head.Position))
				--	end
			--	end
			--	targetinfo.UpdateInfo(targettable, targetsize)
		--	end
		--until BowAura["Enabled"] == false
--	end)
--end, function() end, true)
--bowaurarange = BowAura.CreateSlider("Bow Range", 1, 70, function(val) end, 70)
--BowDelay2 = BowAura.CreateSlider("Bow Delay", 1, 20, function(val) end, 5)
--BowTargets = BowAura.CreateSlider("Bow Targets", 1, 20, function(val) end, 1)]]

local NoFall = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("NoFall", function()
	OldNoFallFunction = bedwars["damageTable"]["requestSelfDamage"]
	bedwars["damageTable"]["requestSelfDamage"] = function() end
end, function()
	bedwars["damageTable"]["requestSelfDamage"] = OldNoFallFunction
end, true, function() return "" end, "Prevents taking fall damage.")

local NoSlowdown = {["Enabled"] = false}
local OldSetSpeedFunc
NoSlowdown = GuiLibrary["ObjectsThatCanBeSaved"]["BlatantWindow"]["Api"].CreateOptionsButton("NoSlowdown", function()
	OldSetSpeedFunc = bedwars["sprintTable"]["setSpeed"]
	bedwars["sprintTable"]["setSpeed"] = function(tab1, val1)
		spawn(function()
			if lplr.Character then
				local hum = lplr.Character:WaitForChild("Humanoid")
				if hum then
					hum.WalkSpeed = (bedwars["sprintTable"].blockSprint and math.clamp(val1 + 6, 0, 20) or val1)
				end
			end
		end)
	end
end, function() 
	bedwars["sprintTable"]["setSpeed"] = OldSetSpeedFunc
	OldSetSpeedFunc = nil
end, true, function() return "" end, "Prevents slowing down when using items.")
local healthColorToPosition = {
	[Vector3.new(Color3.fromRGB(255, 28, 0).r,
  Color3.fromRGB(255, 28, 0).g,
  Color3.fromRGB(255, 28, 0).b)] = 0.1;
	[Vector3.new(Color3.fromRGB(250, 235, 0).r,
  Color3.fromRGB(250, 235, 0).g,
  Color3.fromRGB(250, 235, 0).b)] = 0.5;
	[Vector3.new(Color3.fromRGB(27, 252, 107).r,
  Color3.fromRGB(27, 252, 107).g,
  Color3.fromRGB(27, 252, 107).b)] = 0.8;
}
local min = 0.1
local minColor = Color3.fromRGB(255, 28, 0)
local max = 0.8
local maxColor = Color3.fromRGB(27, 252, 107)

local function HealthbarColorTransferFunction(healthPercent)
	if healthPercent < min then
		return minColor
	elseif healthPercent > max then
		return maxColor
	end


	local numeratorSum = Vector3.new(0,0,0)
	local denominatorSum = 0
	for colorSampleValue, samplePoint in pairs(healthColorToPosition) do
		local distance = healthPercent - samplePoint
		if distance == 0 then
			
			return Color3.new(colorSampleValue.x, colorSampleValue.y, colorSampleValue.z)
		else
			local wi = 1 / (distance*distance)
			numeratorSum = numeratorSum + wi * colorSampleValue
			denominatorSum = denominatorSum + wi
		end
	end
	local result = numeratorSum / denominatorSum
	return Color3.new(result.x, result.y, result.z)
end

local BedESP = {["Enabled"] = false}
local BedESPFolder = Instance.new("Folder")
BedESPFolder.Name = "BedESPFolder"
BedESPFolder.Parent = GuiLibrary["MainGui"]
local BedESPColor = {["Value"] = 0.44}
local BedESPTransparency = {["Value"] = 1}
local BedESPOnTop = {["Enabled"] = true}
BedESP = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton("BedESP", function() 
	BindToRenderStep("BedESP", 500, function()
		if bedwars["BedTable"] then
			for i,plr in pairs(bedwars["BedTable"]) do
					local thing
					if plr ~= nil and BedESPFolder:FindFirstChild(plr.Name..tostring(plr.Covers.BrickColor)) then
						thing = BedESPFolder[plr.Name..tostring(plr.Covers.BrickColor)]
						for bedespnumber, bedesppart in pairs(thing:GetChildren()) do
							bedesppart.Visible = false
						end
					end
					
					if plr ~= nil and plr.Parent ~= nil and plr:FindFirstChild("Covers") and plr.Covers.BrickColor ~= lplr.Team.TeamColor then
						if BedESPFolder:FindFirstChild(plr.Name..tostring(plr.Covers.BrickColor)) == nil then
							local Bedfolder = Instance.new("Folder")
							Bedfolder.Name = plr.Name..tostring(plr.Covers.BrickColor)
							Bedfolder.Parent = BedESPFolder
							thing = Bedfolder
							for bedespnumber, bedesppart in pairs(plr:GetChildren()) do
								local boxhandle = Instance.new("BoxHandleAdornment")
								boxhandle.Size = bedesppart.Size + Vector3.new(.01, .01, .01)
								boxhandle.AlwaysOnTop = true
								boxhandle.ZIndex = 10
								boxhandle.Visible = true
								boxhandle.Color3 = bedesppart.Color
								boxhandle.Name = bedespnumber
								boxhandle.Parent = Bedfolder
							end
						end
						for bedespnumber, bedesppart in pairs(thing:GetChildren()) do
							bedesppart.Visible = true
							if plr:GetChildren()[bedespnumber] then
								bedesppart.Adornee = plr:GetChildren()[bedespnumber]
							else
								bedesppart.Adornee = nil
							end
						end
					end
			end
		end
	end)
end, function() UnbindFromRenderStep("BedESP") BedESPFolder:ClearAllChildren() end, true, function() return "" end, "Render Beds through walls")

GuiLibrary["RemoveObject"]("NameTagsOptionsButton")
local NameTagsFolder = Instance.new("Folder")
NameTagsFolder.Name = "NameTagsFolder"
NameTagsFolder.Parent = GuiLibrary["MainGui"]
players.PlayerRemoving:connect(function(plr)
	if NameTagsFolder:FindFirstChild(plr.Name) then
		NameTagsFolder[plr.Name]:Remove()
	end
end)
local NameTagsColor = {["Value"] = 0.44}
local NameTagsDisplayName = {["Enabled"] = false}
local NameTagsHealth = {["Enabled"] = false}
local NameTagsDistance = {["Enabled"] = false}
local NameTagsShowInventory = {["Enabled"] = false}
local NameTags = GuiLibrary["ObjectsThatCanBeSaved"]["RenderWindow"]["Api"].CreateOptionsButton("NameTags", function() 
	BindToRenderStep("NameTags", 500, function()
		for i,plr in pairs(players:GetChildren()) do
				local thing
				if NameTagsFolder:FindFirstChild(plr.Name) then
					thing = NameTagsFolder[plr.Name]
					thing.Visible = false
				else
					thing = Instance.new("TextLabel")
					thing.BackgroundTransparency = 0.5
					thing.BackgroundColor3 = Color3.new(0, 0, 0)
					thing.BorderSizePixel = 0
					thing.Visible = false
					thing.RichText = true
					thing.Name = plr.Name
					thing.Font = Enum.Font.SourceSans
					thing.TextSize = 14
					if plr.Character and plr.Character:FindFirstChild("Humanoid") and plr.Character:FindFirstChild("HumanoidRootPart") then
						local rawText = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)
						if NameTagsHealth["Enabled"] then
							rawText = (NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name).." "..math.floor(plr.Character.Humanoid.Health)
						end
						local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
						local modifiedText = (NameTagsDistance["Enabled"] and isAlive() and '<font color="rgb(85, 255, 85)">[</font>'..math.floor((lplr.Character.HumanoidRootPart.Position - plr.Character.HumanoidRootPart.Position).magnitude)..'<font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
						local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
						thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
						thing.Text = modifiedText
					else
						local nametagSize = game:GetService("TextService"):GetTextSize(plr.Name, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
						thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
						thing.Text = plr.Name
					end
					thing.TextColor3 = tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color or (GuiLibrary["ObjectsThatCanBeSaved"]["Use colorToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["FriendsObject"]["Friends"], plr.Name) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1)) or Color3.fromHSV(NameTagsColor["Value"], 1, 1)
					thing.Parent = NameTagsFolder
					local hand = Instance.new("ImageLabel")
					hand.Size = UDim2.new(0, 30, 0, 30)
					hand.Name = "Hand"
					hand.BackgroundTransparency = 1
					hand.Position = UDim2.new(0, -30, 0, -30)
					hand.Image = ""
					hand.Parent = thing
					local helmet = hand:Clone()
					helmet.Name = "Helmet"
					helmet.Position = UDim2.new(0, 5, 0, -30)
					helmet.Parent = thing
					local chest = hand:Clone()
					chest.Name = "Chestplate"
					chest.Position = UDim2.new(0, 35, 0, -30)
					chest.Parent = thing
					local boots = hand:Clone()
					boots.Name = "Boots"
					boots.Position = UDim2.new(0, 65, 0, -30)
					boots.Parent = thing
				end
				
				if isPlayerTargetable(plr, false, false) then
					local headPos, headVis = cam:WorldToViewportPoint((plr.Character.HumanoidRootPart:GetRenderCFrame() * CFrame.new(0, plr.Character.Head.Size.Y + plr.Character.HumanoidRootPart.Size.Y, 0)).Position)
					headPos = headPos * (1 / GuiLibrary["MainRescale"].Scale)
					
					if headVis then
						local inventory = bedwars["getInventory"](plr)
						if inventory.hand then
							thing.Hand.Image = bedwars["getIcon"](inventory.hand, NameTagsShowInventory["Enabled"])
						end
						if inventory.armor[4] then
							thing.Helmet.Image = bedwars["getIcon"](inventory.armor[4], NameTagsShowInventory["Enabled"])
						end
						if inventory.armor[5] then
							thing.Chestplate.Image = bedwars["getIcon"](inventory.armor[5], NameTagsShowInventory["Enabled"])
						end
						if inventory.armor[6] then
							thing.Boots.Image = bedwars["getIcon"](inventory.armor[6], NameTagsShowInventory["Enabled"])
						end
						local blocksaway = math.floor(((isAlive() and lplr.Character.HumanoidRootPart.Position or Vector3.new(0,0,0)) - plr.Character.HumanoidRootPart.Position).magnitude / 3)
						local rawText = (NameTagsDistance["Enabled"] and isAlive() and "["..blocksaway.."] " or "")..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and " "..math.floor(plr.Character.Humanoid.Health) or "")
						local color = HealthbarColorTransferFunction(plr.Character.Humanoid.Health / plr.Character.Humanoid.MaxHealth)
						local modifiedText = (NameTagsDistance["Enabled"] and isAlive() and '<font color="rgb(85, 255, 85)">[</font><font color="rgb(255, 255, 255)">'..blocksaway..'</font><font color="rgb(85, 255, 85)">]</font> ' or '')..(NameTagsDisplayName["Enabled"] and plr.DisplayName ~= nil and plr.DisplayName or plr.Name)..(NameTagsHealth["Enabled"] and ' <font color="rgb('..tostring(math.floor(color.R * 255))..','..tostring(math.floor(color.G * 255))..','..tostring(math.floor(color.B * 255))..')">'..math.floor(plr.Character.Humanoid.Health).."</font>" or '')
						local nametagSize = game:GetService("TextService"):GetTextSize(rawText, thing.TextSize, thing.Font, Vector2.new(100000, 100000))
						thing.Size = UDim2.new(0, nametagSize.X + 4, 0, nametagSize.Y)
						thing.Text = modifiedText
						thing.TextColor3 = tostring(plr.TeamColor) ~= "White" and plr.TeamColor.Color or (GuiLibrary["ObjectsThatCanBeSaved"]["Use colorToggle"]["Api"]["Enabled"] and table.find(GuiLibrary["FriendsObject"]["Friends"], plr.Name) and Color3.fromHSV(GuiLibrary["ObjectsThatCanBeSaved"]["Friends ColorSliderColor"]["Api"]["Value"], 1, 1)) or Color3.fromHSV(NameTagsColor["Value"], 1, 1)
						thing.Visible = headVis
						thing.Position = UDim2.new(0, headPos.X - thing.Size.X.Offset / 2, 0, (headPos.Y - thing.Size.Y.Offset) - 36)
					end
				end
			end

	end)
end, function() UnbindFromRenderStep("NameTags") NameTagsFolder:ClearAllChildren() end, true)
NameTagsColor = NameTags.CreateColorSlider("Player Color", function(val) end)
NameTagsDisplayName = NameTags.CreateToggle("Use Display Name", function() end, function() end, true)
NameTagsHealth = NameTags.CreateToggle("Health", function() end, function() end, true)
NameTagsDistance = NameTags.CreateToggle("Distance", function() end, function() end)
NameTagsShowInventory = NameTags.CreateToggle("Equipment", function() end, function() end, true)